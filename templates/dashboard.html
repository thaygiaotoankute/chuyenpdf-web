{% extends "base.html" %}

{% block title %}P_Convert - Dashboard{% endblock %}

{% block head %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
<style>
.loading-spinner {
    display: none;
    margin: 10px 0;
    text-align: center;
}
.loading-spinner .spinner {
    display: inline-block;
    vertical-align: middle;
}
.status-message {
    padding: 10px;
    margin: 10px 0;
    border-radius: 4px;
    display: none;
}
.status-message.info {
    background-color: #d1ecf1;
    border: 1px solid #bee5eb;
    color: #0c5460;
}
.status-message.success {
    background-color: #d4edda;
    border: 1px solid #c3e6cb;
    color: #155724;
}
.status-message.warning {
    background-color: #fff3cd;
    border: 1px solid #ffeeba;
    color: #856404;
}
.status-message.danger {
    background-color: #f8d7da;
    border: 1px solid #f5c6cb;
    color: #721c24;
}
.progress-text {
    margin-top: 5px;
    font-size: 12px;
    color: #666;
}
code {
    background-color: #f5f5f5;
    padding: 2px 4px;
    border-radius: 4px;
    font-family: monospace;
}
.export-dialog button:hover {
    opacity: 0.9;
}
</style>
{% endblock %}

{% block content %}
<div class="main-content">
    <h1>P_Convert_2025_Special (PDF:Word-Image-Equation)</h1>
    <p>C√¥ng c·ª• chuy·ªÉn ƒë·ªïi PDF th√†nh vƒÉn b·∫£n, h√¨nh ·∫£nh v√† c√¥ng th·ª©c to√°n h·ªçc</p>
    
    <!-- API Keys Card -->
    <div class="card">
        <h2 class="card-title">API Keys</h2>
        <div class="form-group">
            <label for="mineru-token">Mineru Token</label>
            <input type="password" id="mineru-token" placeholder="Nh·∫≠p Mineru Token...">
            <button class="btn-toggle-password" data-target="mineru-token">üëÅ</button>
        </div>
        <div class="form-group">
            <label for="gemini-key">Gemini API Key</label>
            <input type="password" id="gemini-key" placeholder="Nh·∫≠p Gemini API Key...">
            <button class="btn-toggle-password" data-target="gemini-key">üëÅ</button>
        </div>
    </div>
    
    <!-- File Upload Card -->
    <div class="card">
        <h2 class="card-title">Upload PDF</h2>
        <div class="file-drop-area" id="file-drop-area">
            <p>K√©o th·∫£ file PDF v√†o ƒë√¢y ho·∫∑c <strong>Click ƒë·ªÉ ch·ªçn file</strong></p>
            <input type="file" id="file-input" class="file-input" accept=".pdf">
        </div>
        
        <div id="file-info-container" class="hidden">
            <div class="file-info">
                <div class="file-name" id="file-name"></div>
                <div class="file-size" id="file-size"></div>
                <button class="btn-error" id="btn-remove-file">X√≥a</button>
            </div>
        </div>
    </div>
    
    <!-- Tabs Card -->
    <div class="card" id="processing-options" style="display: none;">
        <div class="tabs">
            <div class="tab active" data-tab="full-pdf">X·ª≠ l√Ω to√†n b·ªô PDF</div>
            <div class="tab" data-tab="split-pdf">T√°ch v√† x·ª≠ l√Ω t·ª´ng ph·∫ßn</div>
        </div>
        
        <!-- Tab Content -->
        <div class="tab-content active" id="full-pdf-tab">
            <p>X·ª≠ l√Ω to√†n b·ªô file PDF v√† tr√≠ch xu·∫•t th√†nh vƒÉn b·∫£n</p>
            <button class="btn" id="btn-process-all">Upload & Parse (To√†n b·ªô PDF)</button>
            <div class="progress-container" id="progress-container-full" style="display: none;">
                <div class="progress-bar" id="progress-bar-full"></div>
            </div>
            <div id="status-text-full" class="status-text"></div>
        </div>
        
        <div class="tab-content" id="split-pdf-tab">
            <p>T√°ch PDF th√†nh nhi·ªÅu ph·∫ßn ƒë·ªÉ x·ª≠ l√Ω t·ª´ng ph·∫ßn</p>
            <button class="btn" id="btn-split-pdf">T√°ch PDF</button>
            <div id="parts-container" style="display: none;">
                <h3>C√°c ph·∫ßn ƒë√£ t√°ch</h3>
                <ul class="parts-list" id="parts-list"></ul>
                <div class="action-buttons">
                    <button class="btn" id="btn-process-selected-part">X·ª≠ l√Ω ph·∫ßn ƒë√£ ch·ªçn</button>
                    <button class="btn" id="btn-process-all-parts">X·ª≠ l√Ω t·∫•t c·∫£ c√°c ph·∫ßn</button>
                </div>
                <div class="progress-container" id="progress-container-part" style="display: none;">
                    <div class="progress-bar" id="progress-bar-part"></div>
                </div>
                <div id="status-text-part" class="status-text"></div>
            </div>
        </div>
    </div>
    
    <!-- Results Card -->
    <div class="card" id="results-card" style="display: none;">
        <h2 class="card-title">K·∫øt qu·∫£</h2>
        <div class="tabs">
            <div class="tab active" data-tab="preview">Xem k·∫øt qu·∫£</div>
            <div class="tab" data-tab="download">T·∫£i xu·ªëng</div>
        </div>
        
        <div class="tab-content active" id="preview-tab">
            <div class="markdown-preview" id="markdown-preview"></div>
        </div>
        
        <div class="tab-content" id="download-tab">
            <p>T·∫£i xu·ªëng k·∫øt qu·∫£</p>
            <div class="action-buttons">
                <a class="btn" id="btn-download-md">T·∫£i xu·ªëng d∆∞·ªõi d·∫°ng Markdown</a>
                <a class="btn" id="btn-download-txt">T·∫£i xu·ªëng d∆∞·ªõi d·∫°ng Text</a>
                <button class="btn btn-success" id="btn-to-word">Chuy·ªÉn sang Word (API)</button>
            </div>
            
            <!-- Loading spinner v√† status message cho Word conversion -->
            <div class="loading-spinner" id="outputLoading">
                <div class="spinner"></div>
                <span>ƒêang x·ª≠ l√Ω...</span>
            </div>
            <div class="status-message" id="status-message"></div>
            <div class="progress-text" id="progress-text"></div>
            
            <div class="alert alert-info">
                Ch·ª©c nƒÉng chuy·ªÉn ƒë·ªïi sang Word h·ªó tr·ª£ c·∫£ h√¨nh ·∫£nh t·ª´ server v√† blob URLs. H√£y s·ª≠ d·ª•ng t√πy ch·ªçn ch·∫•t l∆∞·ª£ng th·∫•p h∆°n n·∫øu g·∫∑p v·∫•n ƒë·ªÅ v·ªõi t√†i li·ªáu l·ªõn.
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Variables
    let fileId = null;
    let fileName = null;
    let fileData = null;
    let activeTaskId = null;
    let selectedPartId = null;
    let parts = [];
    let resultText = '';
    let currentMarkdownContent = ''; // Bi·∫øn l∆∞u n·ªôi dung markdown hi·ªán t·∫°i
    
    // Elements
    const fileDropArea = document.getElementById('file-drop-area');
    const fileInput = document.getElementById('file-input');
    const fileInfoContainer = document.getElementById('file-info-container');
    const fileNameEl = document.getElementById('file-name');
    const fileSizeEl = document.getElementById('file-size');
    const btnRemoveFile = document.getElementById('btn-remove-file');
    const processingOptions = document.getElementById('processing-options');
    const btnProcessAll = document.getElementById('btn-process-all');
    const btnSplitPdf = document.getElementById('btn-split-pdf');
    const progressContainerFull = document.getElementById('progress-container-full');
    const progressBarFull = document.getElementById('progress-bar-full');
    const statusTextFull = document.getElementById('status-text-full');
    const partsContainer = document.getElementById('parts-container');
    const partsList = document.getElementById('parts-list');
    const btnProcessSelectedPart = document.getElementById('btn-process-selected-part');
    const btnProcessAllParts = document.getElementById('btn-process-all-parts');
    const progressContainerPart = document.getElementById('progress-container-part');
    const progressBarPart = document.getElementById('progress-bar-part');
    const statusTextPart = document.getElementById('status-text-part');
    const resultsCard = document.getElementById('results-card');
    const markdownPreview = document.getElementById('markdown-preview');
    const btnDownloadMd = document.getElementById('btn-download-md');
    const btnDownloadTxt = document.getElementById('btn-download-txt');
    const btnToWord = document.getElementById('btn-to-word');
    const outputLoading = document.getElementById('outputLoading');
    const statusMessage = document.getElementById('status-message');
    const progressText = document.getElementById('progress-text');
    
    // Password Toggle
    document.querySelectorAll('.btn-toggle-password').forEach(function(button) {
        button.addEventListener('click', function() {
            const targetId = this.getAttribute('data-target');
            const input = document.getElementById(targetId);
            if (input.type === 'password') {
                input.type = 'text';
            } else {
                input.type = 'password';
            }
        });
    });
    
    // Tab Switching
    document.querySelectorAll('.tab').forEach(function(tab) {
        tab.addEventListener('click', function() {
            const tabId = this.getAttribute('data-tab');
            
            // Update active tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            this.classList.add('active');
            
            // Update active tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabId + '-tab').classList.add('active');
        });
    });
    
    // File Upload Handling
    fileDropArea.addEventListener('click', function() {
        fileInput.click();
    });
    
    fileDropArea.addEventListener('dragover', function(e) {
        e.preventDefault();
        fileDropArea.classList.add('dragover');
    });
    
    fileDropArea.addEventListener('dragleave', function() {
        fileDropArea.classList.remove('dragover');
    });
    
    fileDropArea.addEventListener('drop', function(e) {
        e.preventDefault();
        fileDropArea.classList.remove('dragover');
        
        if (e.dataTransfer.files.length) {
            handleFileUpload(e.dataTransfer.files[0]);
        }
    });
    
    fileInput.addEventListener('change', function() {
        if (fileInput.files.length) {
            handleFileUpload(fileInput.files[0]);
        }
    });
    
    btnRemoveFile.addEventListener('click', function() {
        resetFileUpload();
    });
    
    function handleFileUpload(file) {
        if (!file.type || file.type !== 'application/pdf') {
            alert('Ch·ªâ ch·∫•p nh·∫≠n file PDF!');
            return;
        }
        
        // Display file info
        fileName = file.name;
        fileNameEl.textContent = fileName;
        fileSizeEl.textContent = formatFileSize(file.size);
        fileInfoContainer.style.display = 'block';
        processingOptions.style.display = 'block';
        
        // Upload file to server
        const formData = new FormData();
        formData.append('pdf_file', file);
        
        fetch('/upload', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                fileId = data.file_id;
                // Show success message
                console.log('File uploaded successfully', data);
            } else {
                alert(data.error || 'Upload failed');
                resetFileUpload();
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error uploading file');
            resetFileUpload();
        });
    }
    
    function resetFileUpload() {
        fileInput.value = '';
        fileInfoContainer.style.display = 'none';
        processingOptions.style.display = 'none';
        partsContainer.style.display = 'none';
        resultsCard.style.display = 'none';
        fileId = null;
        fileName = null;
        parts = [];
        currentMarkdownContent = '';
    }
    
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    // Process Full PDF
    btnProcessAll.addEventListener('click', function() {
        if (!fileId) {
            alert('Vui l√≤ng ch·ªçn file PDF tr∆∞·ªõc');
            return;
        }
        
        const mineruToken = document.getElementById('mineru-token').value;
        const geminiKey = document.getElementById('gemini-key').value;
        
        if (!mineruToken) {
            alert('Vui l√≤ng nh·∫≠p Mineru Token');
            return;
        }
        
        // Show progress bar
        progressContainerFull.style.display = 'block';
        progressBarFull.style.width = '0%';
        statusTextFull.textContent = 'ƒêang b·∫Øt ƒë·∫ßu x·ª≠ l√Ω...';
        btnProcessAll.disabled = true;
        
        fetch('/process', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                file_id: fileId,
                filename: fileName,
                mineru_token: mineruToken,
                gemini_key: geminiKey
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                activeTaskId = data.task_id;
                // Poll for task status
                pollTaskStatus(activeTaskId, updateFullPdfProgress);
            } else {
                alert(data.error || 'Processing failed');
                progressContainerFull.style.display = 'none';
                btnProcessAll.disabled = false;
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error processing file');
            progressContainerFull.style.display = 'none';
            btnProcessAll.disabled = false;
        });
    });
    
    function updateFullPdfProgress(taskInfo) {
        progressBarFull.style.width = taskInfo.progress + '%';
        
        switch (taskInfo.status) {
            case 'initialized':
                statusTextFull.textContent = 'Kh·ªüi t·∫°o...';
                break;
            case 'uploading':
                statusTextFull.textContent = 'ƒêang upload PDF...';
                break;
            case 'processing':
                statusTextFull.textContent = 'ƒêang x·ª≠ l√Ω PDF...';
                break;
            case 'downloading':
                statusTextFull.textContent = 'ƒêang t·∫£i k·∫øt qu·∫£...';
                break;
            case 'correcting':
                statusTextFull.textContent = 'ƒêang hi·ªáu ƒë√≠nh n·ªôi dung v·ªõi Gemini...';
                break;
            case 'completed':
                statusTextFull.textContent = 'ƒê√£ ho√†n th√†nh!';
                getTaskResult(activeTaskId);
                btnProcessAll.disabled = false;
                break;
            case 'error':
                statusTextFull.textContent = 'L·ªói: ' + taskInfo.error;
                btnProcessAll.disabled = false;
                break;
            case 'cancelled':
                statusTextFull.textContent = 'ƒê√£ h·ªßy x·ª≠ l√Ω';
                btnProcessAll.disabled = false;
                break;
            default:
                statusTextFull.textContent = 'ƒêang x·ª≠ l√Ω...';
        }
    }
    
    // Split PDF
    btnSplitPdf.addEventListener('click', function() {
        if (!fileId) {
            alert('Vui l√≤ng ch·ªçn file PDF tr∆∞·ªõc');
            return;
        }
        
        btnSplitPdf.disabled = true;
        statusTextPart.textContent = 'ƒêang t√°ch PDF...';
        
        fetch('/split-pdf', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                file_id: fileId,
                filename: fileName
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                parts = data.parts;
                
                // Display parts list
                partsList.innerHTML = '';
                parts.forEach(part => {
                    const li = document.createElement('li');
                    li.className = 'part-item';
                    li.dataset.partId = part.id;
                    li.textContent = part.name;
                    li.addEventListener('click', function() {
                        // Select part
                        document.querySelectorAll('.part-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        this.classList.add('selected');
                        selectedPartId = part.id;
                    });
                    partsList.appendChild(li);
                });
                
                partsContainer.style.display = 'block';
                statusTextPart.textContent = 'PDF ƒë√£ ƒë∆∞·ª£c t√°ch th√†nh ' + parts.length + ' ph·∫ßn';
            } else {
                alert(data.error || 'Split failed');
            }
            btnSplitPdf.disabled = false;
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error splitting file');
            btnSplitPdf.disabled = false;
        });
    });
    
    // Process Selected Part
    btnProcessSelectedPart.addEventListener('click', function() {
        if (!selectedPartId) {
            alert('Vui l√≤ng ch·ªçn m·ªôt ph·∫ßn ƒë·ªÉ x·ª≠ l√Ω');
            return;
        }
        
        processSelectedPart(selectedPartId);
    });
    
    function processSelectedPart(partId) {
        const mineruToken = document.getElementById('mineru-token').value;
        const geminiKey = document.getElementById('gemini-key').value;
        
        if (!mineruToken) {
            alert('Vui l√≤ng nh·∫≠p Mineru Token');
            return;
        }
        
        // Show progress
        progressContainerPart.style.display = 'block';
        progressBarPart.style.width = '0%';
        statusTextPart.textContent = 'ƒêang b·∫Øt ƒë·∫ßu x·ª≠ l√Ω ph·∫ßn ' + partId + '...';
        btnProcessSelectedPart.disabled = true;
        btnProcessAllParts.disabled = true;
        
        fetch('/process-part', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                file_id: fileId,
                part_id: partId,
                mineru_token: mineruToken,
                gemini_key: geminiKey
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                activeTaskId = data.task_id;
                // Poll for task status
                pollTaskStatus(activeTaskId, updatePartProgress);
            } else {
                alert(data.error || 'Processing failed');
                progressContainerPart.style.display = 'none';
                btnProcessSelectedPart.disabled = false;
                btnProcessAllParts.disabled = false;
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error processing part');
            progressContainerPart.style.display = 'none';
            btnProcessSelectedPart.disabled = false;
            btnProcessAllParts.disabled = false;
        });
    }
    
    // Process All Parts
    btnProcessAllParts.addEventListener('click', function() {
        if (parts.length === 0) {
            alert('Kh√¥ng c√≥ ph·∫ßn n√†o ƒë·ªÉ x·ª≠ l√Ω');
            return;
        }
        
        // Reset result text before processing all parts
        resultText = '';
        
        // Process first part
        processAllPartsSequentially(0);
    });
    
    function processAllPartsSequentially(index) {
        if (index >= parts.length) {
            // All parts are processed
            btnProcessSelectedPart.disabled = false;
            btnProcessAllParts.disabled = false;
            return;
        }
        
        const partId = parts[index].id;
        const mineruToken = document.getElementById('mineru-token').value;
        const geminiKey = document.getElementById('gemini-key').value;
        
        if (!mineruToken) {
            alert('Vui l√≤ng nh·∫≠p Mineru Token');
            return;
        }
        
        // Show progress
        progressContainerPart.style.display = 'block';
        progressBarPart.style.width = '0%';
        statusTextPart.textContent = `ƒêang x·ª≠ l√Ω ph·∫ßn ${index+1}/${parts.length}...`;
        btnProcessSelectedPart.disabled = true;
        btnProcessAllParts.disabled = true;
        
        fetch('/process-part', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                file_id: fileId,
                part_id: partId,
                mineru_token: mineruToken,
                gemini_key: geminiKey
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                activeTaskId = data.task_id;
                
                // Set up callback for when this part is done
                const originalPollCallback = pollTaskStatus(activeTaskId, updatePartProgress, () => {
                    // After this part is done, process the next part
                    setTimeout(() => {
                        processAllPartsSequentially(index + 1);
                    }, 1000);
                });
            } else {
                alert(data.error || 'Processing failed');
                progressContainerPart.style.display = 'none';
                btnProcessSelectedPart.disabled = false;
                btnProcessAllParts.disabled = false;
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error processing parts');
            progressContainerPart.style.display = 'none';
            btnProcessSelectedPart.disabled = false;
            btnProcessAllParts.disabled = false;
        });
    }
    
    function updatePartProgress(taskInfo) {
        progressBarPart.style.width = taskInfo.progress + '%';
        
        switch (taskInfo.status) {
            case 'initialized':
                statusTextPart.textContent = 'Kh·ªüi t·∫°o...';
                break;
            case 'uploading':
                statusTextPart.textContent = 'ƒêang upload PDF...';
                break;
            case 'processing':
                statusTextPart.textContent = 'ƒêang x·ª≠ l√Ω PDF...';
                break;
            case 'downloading':
                statusTextPart.textContent = 'ƒêang t·∫£i k·∫øt qu·∫£...';
                break;
            case 'correcting':
                statusTextPart.textContent = 'ƒêang hi·ªáu ƒë√≠nh n·ªôi dung v·ªõi Gemini...';
                break;
            case 'completed':
                statusTextPart.textContent = 'ƒê√£ ho√†n th√†nh!';
                getTaskResult(activeTaskId, true);
                btnProcessSelectedPart.disabled = false;
                btnProcessAllParts.disabled = false;
                break;
            case 'error':
                statusTextPart.textContent = 'L·ªói: ' + taskInfo.error;
                btnProcessSelectedPart.disabled = false;
                btnProcessAllParts.disabled = false;
                break;
            case 'cancelled':
                statusTextPart.textContent = 'ƒê√£ h·ªßy x·ª≠ l√Ω';
                btnProcessSelectedPart.disabled = false;
                btnProcessAllParts.disabled = false;
                break;
            default:
                statusTextPart.textContent = 'ƒêang x·ª≠ l√Ω...';
        }
    }
    
    // Task Status Polling
    function pollTaskStatus(taskId, updateCallback, completionCallback = null) {
        const poll = () => {
            fetch(`/task-status/${taskId}`)
                .then(response => response.json())
                .then(taskInfo => {
                    updateCallback(taskInfo);
                    
                    if (['completed', 'error', 'cancelled'].includes(taskInfo.status)) {
                        if (completionCallback) {
                            completionCallback();
                        }
                        return;
                    }
                    
                    // Continue polling
                    setTimeout(poll, 1000);
                })
                .catch(error => {
                    console.error('Error polling task status:', error);
                    // Retry after a delay
                    setTimeout(poll, 2000);
                });
        };
        
        // Start polling
        poll();
    }
    
    // Get Task Result
    function getTaskResult(taskId, append = false) {
        fetch(`/task-result/${taskId}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    if (append) {
                        // Append result to existing text
                        if (resultText) {
                            resultText += '\n\n';
                        }
                        
                        if (data.part_name) {
                            resultText += `--- K·∫øt qu·∫£ t·ª´ ${data.part_name} ---\n`;
                        }
                        
                        resultText += data.result;
                    } else {
                        // Replace existing result
                        resultText = data.result;
                    }
                    
                    // Update current markdown content for Word conversion
                    currentMarkdownContent = resultText;
                    
                    // Update preview
                    markdownPreview.innerHTML = marked.parse(resultText);
                    
                    // Update download links
                    btnDownloadMd.href = `/download/${taskId}/markdown`;
                    btnDownloadTxt.href = `/download/${taskId}/text`;
                    
                    // Show results card
                    resultsCard.style.display = 'block';
                }
            })
            .catch(error => {
                console.error('Error getting result:', error);
            });
    }
    
    // Hi·ªÉn th·ªã th√¥ng b√°o tr·∫°ng th√°i
    function showStatus(message, type) {
        statusMessage.innerHTML = message;
        statusMessage.className = 'status-message ' + type;
        statusMessage.style.display = 'block';
        
        // T·ª± ƒë·ªông ·∫©n th√¥ng b√°o th√†nh c√¥ng sau 5 gi√¢y
        if (type === 'success') {
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        }
    }
    
    // Hi·ªÉn th·ªã th√¥ng tin ti·∫øn tr√¨nh
    function showProgressInfo(message) {
        progressText.textContent = message;
        progressText.style.display = 'block';
    }
    
    // H√†m hi·ªÉn th·ªã dialog c√†i ƒë·∫∑t xu·∫•t Word
    function showExportSettingsDialog() {
      // T·∫°o v√† hi·ªÉn th·ªã dialog
      const dialog = document.createElement('div');
      dialog.className = 'export-dialog';
      dialog.style.position = 'fixed';
      dialog.style.top = '50%';
      dialog.style.left = '50%';
      dialog.style.transform = 'translate(-50%, -50%)';
      dialog.style.backgroundColor = 'white';
      dialog.style.padding = '20px';
      dialog.style.borderRadius = '8px';
      dialog.style.boxShadow = '0 4px 10px rgba(0,0,0,0.3)';
      dialog.style.zIndex = '1000';
      dialog.style.minWidth = '400px';
      dialog.style.maxWidth = '600px';

      // N·ªÅn m·ªù
      const overlay = document.createElement('div');
      overlay.style.position = 'fixed';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.right = '0';
      overlay.style.bottom = '0';
      overlay.style.backgroundColor = 'rgba(0,0,0,0.5)';
      overlay.style.zIndex = '999';

      // N·ªôi dung dialog
      dialog.innerHTML = `
        <h3 style="margin-top:0">C√†i ƒë·∫∑t xu·∫•t Word</h3>
        
        <div style="margin:15px 0">
          <label style="display:block;margin-bottom:5px">Ch·ªçn ph∆∞∆°ng ph√°p x·ª≠ l√Ω:</label>
          <select id="export-method" style="width:100%;padding:8px;border-radius:4px;border:1px solid #ddd">
            <option value="direct">G·ª≠i tr·ª±c ti·∫øp ƒë·∫øn API (t·ªët nh·∫•t cho n·ªôi dung nh·ªè)</option>
            <option value="split">Chia nh·ªè th√†nh nhi·ªÅu file (t·ªët nh·∫•t cho n·ªôi dung l·ªõn)</option>
            <option value="download">T·∫£i xu·ªëng Markdown v√† x·ª≠ l√Ω c·ª•c b·ªô</option>
          </select>
        </div>
        
        <div style="margin:15px 0">
          <label style="display:block;margin-bottom:5px">Ch·∫•t l∆∞·ª£ng h√¨nh ·∫£nh:</label>
          <select id="image-quality" style="width:100%;padding:8px;border-radius:4px;border:1px solid #ddd">
            <option value="high">Cao (90% ch·∫•t l∆∞·ª£ng, 800px)</option>
            <option value="medium" selected>Trung b√¨nh (60% ch·∫•t l∆∞·ª£ng, 600px)</option>
            <option value="low">Th·∫•p (40% ch·∫•t l∆∞·ª£ng, 400px)</option>
            <option value="very-low">R·∫•t th·∫•p (20% ch·∫•t l∆∞·ª£ng, 300px)</option>
          </select>
          <small style="display:block;margin-top:5px;color:#666">Ch·∫•t l∆∞·ª£ng th·∫•p h∆°n = k√≠ch th∆∞·ªõc file nh·ªè h∆°n</small>
        </div>
        
        <div style="margin:15px 0">
          <label style="display:block;margin-bottom:5px">Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc API:</label>
          <select id="size-limit" style="width:100%;padding:8px;border-radius:4px;border:1px solid #ddd">
            <option value="1000">B·∫£o th·ªß (1MB) - ƒê·ªÅ xu·∫•t cho k·∫øt n·ªëi ch·∫≠m</option>
            <option value="2000" selected>Trung b√¨nh (2MB) - ƒê·ªÅ xu·∫•t cho h·∫ßu h·∫øt ng∆∞·ªùi d√πng</option>
            <option value="3000">R·ªông r√£i (3MB) - Cho k·∫øt n·ªëi nhanh</option>
            <option value="5000">M·∫°o hi·ªÉm (5MB) - C√≥ th·ªÉ g√¢y l·ªói API</option>
          </select>
        </div>
        
        <div style="text-align:right;margin-top:20px">
          <button id="cancel-export" style="padding:8px 15px;margin-right:10px;border:1px solid #ddd;background:#f5f5f5;border-radius:4px;cursor:pointer">H·ªßy</button>
          <button id="confirm-export" style="padding:8px 15px;background:#FF4B4B;color:white;border:none;border-radius:4px;cursor:pointer">X√°c nh·∫≠n</button>
        </div>
      `;

      // Th√™m v√†o body
      document.body.appendChild(overlay);
      document.body.appendChild(dialog);

      // X·ª≠ l√Ω s·ª± ki·ªán
      return new Promise((resolve, reject) => {
        document.getElementById('cancel-export').addEventListener('click', () => {
          document.body.removeChild(dialog);
          document.body.removeChild(overlay);
          reject('ƒê√£ h·ªßy xu·∫•t Word');
        });

        document.getElementById('confirm-export').addEventListener('click', () => {
          const settings = {
            method: document.getElementById('export-method').value,
            imageQuality: document.getElementById('image-quality').value,
            sizeLimit: parseInt(document.getElementById('size-limit').value)
          };
          document.body.removeChild(dialog);
          document.body.removeChild(overlay);
          resolve(settings);
        });
      });
    }
    
    // H√†m chuy·ªÉn ƒë·ªïi h√¨nh ·∫£nh sang base64
    async function convertImageToBase64(blobUrl, maxWidth = 800, quality = 0.7) {
      try {
        // T·∫£i h√¨nh ·∫£nh t·ª´ blob URL
        const response = await fetch(blobUrl);
        const imageBlob = await response.blob();
        
        return new Promise((resolve, reject) => {
          // T·∫°o m·ªôt ƒë·ªëi t∆∞·ª£ng Image
          const img = new Image();
          img.onload = () => {
            // T·∫°o canvas ƒë·ªÉ resize h√¨nh ·∫£nh
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;
            
            // Gi·∫£m k√≠ch th∆∞·ªõc n·∫øu c·∫ßn
            if (width > maxWidth) {
              height = Math.floor(height * (maxWidth / width));
              width = maxWidth;
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // V·∫Ω h√¨nh ·∫£nh ƒë√£ resize v√†o canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            // Chuy·ªÉn ƒë·ªïi canvas th√†nh base64 v·ªõi ch·∫•t l∆∞·ª£ng t√πy ch·ªânh
            const base64 = canvas.toDataURL('image/jpeg', quality);
            resolve(base64);
          };
          
          img.onerror = () => {
            // N·∫øu kh√¥ng th·ªÉ optimize, tr·∫£ v·ªÅ d·ªØ li·ªáu g·ªëc d∆∞·ªõi d·∫°ng base64
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(imageBlob);
          };
          
          // Thi·∫øt l·∫≠p src cho h√¨nh ·∫£nh
          img.src = URL.createObjectURL(imageBlob);
        });
      } catch (error) {
        console.error('L·ªói khi chuy·ªÉn ƒë·ªïi h√¨nh ·∫£nh sang base64:', error);
        return null;
      }
    }
    
    // H√†m t·∫£i v√† chuy·ªÉn ƒë·ªïi h√¨nh ·∫£nh t·ª´ m√°y ch·ªß sang base64
    async function fetchAndConvertToBase64(imgPath, maxWidth = 800, quality = 0.7) {
      try {
        // T·∫°o URL tuy·ªát ƒë·ªëi t·ª´ ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi
        const absoluteUrl = new URL(imgPath, window.location.origin).href;
        
        // T·∫£i h√¨nh ·∫£nh t·ª´ m√°y ch·ªß
        const response = await fetch(absoluteUrl);
        if (!response.ok) {
          throw new Error(`Kh√¥ng th·ªÉ t·∫£i h√¨nh ·∫£nh: ${response.status} ${response.statusText}`);
        }
        
        // Chuy·ªÉn ƒë·ªïi th√†nh blob
        const blob = await response.blob();
        
        // T·∫°o ƒë·ªëi t∆∞·ª£ng Image ƒë·ªÉ resize
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            // T·∫°o canvas ƒë·ªÉ resize h√¨nh ·∫£nh
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;
            
            // Gi·∫£m k√≠ch th∆∞·ªõc n·∫øu c·∫ßn
            if (width > maxWidth) {
              height = Math.floor(height * (maxWidth / width));
              width = maxWidth;
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // V·∫Ω h√¨nh ·∫£nh ƒë√£ resize v√†o canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            // Chuy·ªÉn ƒë·ªïi canvas th√†nh base64 v·ªõi ch·∫•t l∆∞·ª£ng t√πy ch·ªânh
            const base64 = canvas.toDataURL('image/jpeg', quality);
            resolve(base64);
          };
          
          img.onerror = () => {
            // N·∫øu kh√¥ng th·ªÉ t·∫£i ho·∫∑c optimize, chuy·ªÉn ƒë·ªïi blob tr·ª±c ti·∫øp
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          };
          
          // Thi·∫øt l·∫≠p src cho h√¨nh ·∫£nh
          img.src = URL.createObjectURL(blob);
        });
      } catch (error) {
        console.error('L·ªói khi t·∫£i v√† chuy·ªÉn ƒë·ªïi h√¨nh ·∫£nh t·ª´ m√°y ch·ªß:', error);
        return null;
      }
    }
    
    // H√†m chu·∫©n b·ªã markdown v·ªõi h·ªó tr·ª£ c·∫£ ƒë∆∞·ªùng d·∫´n m√°y ch·ªß v√† blob URL
    async function prepareMarkdownForPandoc(markdownContent, qualitySetting = 'medium') {
      // X√°c ƒë·ªãnh c√†i ƒë·∫∑t ch·∫•t l∆∞·ª£ng h√¨nh ·∫£nh
      let maxWidth, quality;
      switch (qualitySetting) {
        case 'high':
          maxWidth = 800;
          quality = 0.9;
          break;
        case 'medium':
          maxWidth = 600;
          quality = 0.6;
          break;
        case 'low':
          maxWidth = 400;
          quality = 0.4;
          break;
        case 'very-low':
          maxWidth = 300;
          quality = 0.2;
          break;
        default:
          maxWidth = 600;
          quality = 0.6;
      }
      
      showStatus(`ƒêang b·∫Øt ƒë·∫ßu x·ª≠ l√Ω h√¨nh ·∫£nh (C√†i ƒë·∫∑t: ${qualitySetting})...`, 'info');
      
      // Regex ƒë·ªÉ t√¨m t·∫•t c·∫£ h√¨nh ·∫£nh trong markdown (bao g·ªìm c·∫£ ƒë∆∞·ªùng d·∫´n tƒ©nh v√† blob)
      const imgRegex = /!\[(.*?)\]\((\/images\/.*?|blob:.*?|data:image\/.*?)\)/g;
      let result = markdownContent;
      let matches = [];
      let match;
      
      // T√¨m t·∫•t c·∫£ c√°c tham chi·∫øu h√¨nh ·∫£nh c·∫ßn x·ª≠ l√Ω
      while ((match = imgRegex.exec(markdownContent)) !== null) {
        matches.push({
          fullMatch: match[0],
          altText: match[1],
          imgPath: match[2]
        });
      }
      
      console.log(`ƒêang x·ª≠ l√Ω ${matches.length} h√¨nh ·∫£nh...`);
      showStatus(`ƒêang x·ª≠ l√Ω ${matches.length} h√¨nh ·∫£nh...`, 'info');
      
      // X·ª≠ l√Ω t·ª´ng h√¨nh ·∫£nh m·ªôt - c√°ch ti·∫øp c·∫≠n tu·∫ßn t·ª±
      for (let i = 0; i < matches.length; i++) {
        const item = matches[i];
        try {
          let base64Data;
          
          // C·∫≠p nh·∫≠t tr·∫°ng th√°i
          showProgressInfo(`ƒêang x·ª≠ l√Ω h√¨nh ·∫£nh ${i+1}/${matches.length}...`);
          
          if (item.imgPath.startsWith('/images/')) {
            // ƒê∆∞·ªùng d·∫´n tƒ©nh t·ª´ m√°y ch·ªß - s·ª≠ d·ª•ng fetch API v·ªõi c√†i ƒë·∫∑t ch·∫•t l∆∞·ª£ng
            base64Data = await fetchAndConvertToBase64(item.imgPath, maxWidth, quality);
          } else if (item.imgPath.startsWith('blob:') || item.imgPath.startsWith('data:image/')) {
            // Blob URL ho·∫∑c data URL - s·ª≠ d·ª•ng ph∆∞∆°ng ph√°p chuy·ªÉn ƒë·ªïi kh√°c v·ªõi c√†i ƒë·∫∑t ch·∫•t l∆∞·ª£ng
            base64Data = await convertImageToBase64(item.imgPath, maxWidth, quality);
          }
          
          if (base64Data) {
            // Thay th·∫ø trong n·ªôi dung markdown
            result = result.replace(item.fullMatch, `![${item.altText}](${base64Data})`);
          }
        } catch (err) {
          console.error(`Kh√¥ng th·ªÉ x·ª≠ l√Ω h√¨nh ·∫£nh: ${item.imgPath.substring(0, 50)}...`, err);
        }
      }
      
      return result;
    }
    
    // H√†m chia n·ªôi dung th√†nh c√°c ph·∫ßn nh·ªè h∆°n
    function splitIntoChunks(markdownContent, maxChunkSize = 500000) {
      const chunks = [];
      let currentChunk = "";
      
      // T√°ch markdown th√†nh c√°c d√≤ng
      const lines = markdownContent.split('\n');
      
      for (const line of lines) {
        // N·∫øu th√™m d√≤ng hi·ªán t·∫°i v√†o chunk hi·ªán t·∫°i kh√¥ng v∆∞·ª£t qu√° k√≠ch th∆∞·ªõc t·ªëi ƒëa
        if ((currentChunk.length + line.length + 1) <= maxChunkSize) {
          currentChunk += line + '\n';
        } else {
          // N·∫øu v∆∞·ª£t qu√°, l∆∞u chunk hi·ªán t·∫°i v√† b·∫Øt ƒë·∫ßu chunk m·ªõi
          chunks.push(currentChunk);
          currentChunk = line + '\n';
        }
      }
      
      // Th√™m chunk cu·ªëi c√πng
      if (currentChunk.length > 0) {
        chunks.push(currentChunk);
      }
      
      return chunks;
    }
    
    // H√†m x·ª≠ l√Ω chia nh·ªè file
    async function processSplitFiles(processedMarkdown) {
      showStatus('ƒêang chia nh·ªè n·ªôi dung th√†nh nhi·ªÅu ph·∫ßn...', 'info');
      
      // Chia nh·ªè n·ªôi dung (m·ªói ph·∫ßn 1.5MB)
      const chunks = splitIntoChunks(processedMarkdown, 1500000);
      console.log(`ƒê√£ chia th√†nh ${chunks.length} ph·∫ßn ƒë·ªÉ x·ª≠ l√Ω`);
      showProgressInfo(`ƒê√£ chia th√†nh ${chunks.length} ph·∫ßn ƒë·ªÉ x·ª≠ l√Ω`);
      
      // T·∫°o t√™n file g·ªëc
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      const baseFileName = `document_${timestamp}`;
      
      // X·ª≠ l√Ω t·ª´ng ph·∫ßn
      for (let i = 0; i < chunks.length; i++) {
        showStatus(`ƒêang x·ª≠ l√Ω ph·∫ßn ${i+1}/${chunks.length}...`, 'info');
        
        try {
          const response = await fetch('https://pandoc-api.onrender.com/convert', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/octet-stream'
            },
            body: JSON.stringify({ markdown: chunks[i] })
          });
          
          if (!response.ok) {
            showStatus(`L·ªói khi x·ª≠ l√Ω ph·∫ßn ${i+1}: ${response.status}`, 'danger');
            continue;
          }
          
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          
          // T·∫°o t√™n file cho m·ªói ph·∫ßn
          a.download = `${baseFileName}_part${i+1}.docx`;
          
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
          
          // Ch·ªù 1 gi√¢y gi·ªØa m·ªói l·∫ßn t·∫£i ƒë·ªÉ tr√°nh qu√° t·∫£i tr√¨nh duy·ªát
          await new Promise(resolve => setTimeout(resolve, 1000));
          
        } catch (error) {
          console.error(`L·ªói khi x·ª≠ l√Ω ph·∫ßn ${i+1}:`, error);
          showStatus(`Kh√¥ng th·ªÉ x·ª≠ l√Ω ph·∫ßn ${i+1}. ƒêang ti·∫øp t·ª•c v·ªõi c√°c ph·∫ßn kh√°c...`, 'danger');
        }
      }
      
      showStatus(`ƒê√£ xu·∫•t ${chunks.length} file Word. H√£y gh√©p ch√∫ng l·∫°i b·∫±ng c√¥ng c·ª• ch·ªânh s·ª≠a vƒÉn b·∫£n.`, 'success');
    }
    
    // H√†m chuy·ªÉn ƒë·ªïi sang word v·ªõi h·ªó tr·ª£ h√¨nh ·∫£nh m√°y ch·ªß
    async function convertOutputToWord() {
      if (!currentMarkdownContent || !currentMarkdownContent.trim()) {
        alert("Kh√¥ng c√≥ k·∫øt qu·∫£ ƒë·ªÉ chuy·ªÉn sang Word!");
        return;
      }
      
      try {
        // Hi·ªÉn th·ªã dialog c√†i ƒë·∫∑t
        const settings = await showExportSettingsDialog();
        
        outputLoading.style.display = 'block';
        
        // X·ª≠ l√Ω h√¨nh ·∫£nh v·ªõi c√†i ƒë·∫∑t ch·∫•t l∆∞·ª£ng ƒë√£ ch·ªçn
        const processedMarkdown = await prepareMarkdownForPandoc(currentMarkdownContent, settings.imageQuality);
        
        // Log k√≠ch th∆∞·ªõc c·ªßa d·ªØ li·ªáu ƒë√£ x·ª≠ l√Ω
        const contentSizeKB = Math.round(processedMarkdown.length / 1024);
        console.log(`K√≠ch th∆∞·ªõc Markdown sau khi x·ª≠ l√Ω: ${contentSizeKB} KB`);
        showProgressInfo(`K√≠ch th∆∞·ªõc d·ªØ li·ªáu: ${contentSizeKB} KB`);
        
        // X·ª≠ l√Ω theo ph∆∞∆°ng ph√°p ƒë√£ ch·ªçn
        if (settings.method === 'download' || (settings.method === 'direct' && contentSizeKB > settings.sizeLimit)) {
          // T·∫£i xu·ªëng Markdown ƒë·ªÉ x·ª≠ l√Ω c·ª•c b·ªô
          showStatus('ƒêang t·∫£i xu·ªëng file Markdown...', settings.method === 'download' ? 'info' : 'warning');
          
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const fileName = `document_${timestamp}.md`;
          
          const blob = new Blob([processedMarkdown], { type: 'text/markdown' });
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fileName;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
          
          showStatus('File Markdown ƒë√£ ƒë∆∞·ª£c t·∫£i xu·ªëng. S·ª≠ d·ª•ng Pandoc c·ª•c b·ªô v·ªõi l·ªánh: <br><code>pandoc ' + fileName + ' -o output.docx</code>', 'info');
        }
        else if (settings.method === 'split' || contentSizeKB > settings.sizeLimit) {
          // Chia nh·ªè v√† x·ª≠ l√Ω t·ª´ng ph·∫ßn
          await processSplitFiles(processedMarkdown);
        }
        else {
          // G·ª≠i tr·ª±c ti·∫øp ƒë·∫øn API
          showStatus('ƒêang chuy·ªÉn ƒë·ªïi sang Word...', 'info');
          
          const response = await fetch('https://pandoc-api.onrender.com/convert', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/octet-stream'
            },
            body: JSON.stringify({ markdown: processedMarkdown })
          });
          
          if (!response.ok) {
            const errorText = await response.text().catch(() => '');
            throw new Error(`HTTP error! status: ${response.status}${errorText ? ': ' + errorText : ''}`);
          }
          
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          a.download = `document_${timestamp}.docx`;
          
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
          
          showStatus('Xu·∫•t file Word th√†nh c√¥ng!', 'success');
        }
      } catch (error) {
        console.error('Error:', error);
        if (error === 'ƒê√£ h·ªßy xu·∫•t Word') {
          showStatus('ƒê√£ h·ªßy xu·∫•t Word', 'info');
        } else if (error.message && error.message.includes('CORS')) {
          showStatus('L·ªói CORS: Website hi·ªán t·∫°i kh√¥ng ƒë∆∞·ª£c ph√©p g·ªçi API Pandoc.', 'danger');
        } else if (error.message && (error.message.includes('413') || error.message.includes('payload too large'))) {
          showStatus('L·ªói: N·ªôi dung qu√° l·ªõn ƒë·ªÉ x·ª≠ l√Ω qua API. Vui l√≤ng th·ª≠ gi·∫£m ch·∫•t l∆∞·ª£ng h√¨nh ·∫£nh ho·∫∑c chia nh·ªè file.', 'danger');
        } else if (error.message && error.message.includes('500')) {
          showStatus('L·ªói m√°y ch·ªß: API Pandoc kh√¥ng th·ªÉ x·ª≠ l√Ω y√™u c·∫ßu.', 'danger');
        } else {
          showStatus('C√≥ l·ªói x·∫£y ra khi chuy·ªÉn ƒë·ªïi: ' + (error.message || error), 'danger');
        }
      } finally {
        outputLoading.style.display = 'none';
      }
    }
    
    // Th√™m event listener cho n√∫t chuy·ªÉn sang Word
    btnToWord.addEventListener('click', convertOutputToWord);
});
</script>
{% endblock %}
