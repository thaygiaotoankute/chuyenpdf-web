{% extends "base.html" %}

{% block title %}P_Convert - Dashboard{% endblock %}

{% block head %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
<style>
.loading-spinner {
    display: none;
    margin: 10px 0;
    text-align: center;
}
.loading-spinner .spinner {
    display: inline-block;
    vertical-align: middle;
}
.status-message {
    padding: 10px;
    margin: 10px 0;
    border-radius: 4px;
    display: none;
}
.status-message.info {
    background-color: #d1ecf1;
    border: 1px solid #bee5eb;
    color: #0c5460;
}
.status-message.success {
    background-color: #d4edda;
    border: 1px solid #c3e6cb;
    color: #155724;
}
.status-message.warning {
    background-color: #fff3cd;
    border: 1px solid #ffeeba;
    color: #856404;
}
.status-message.danger {
    background-color: #f8d7da;
    border: 1px solid #f5c6cb;
    color: #721c24;
}
.progress-text {
    margin-top: 5px;
    font-size: 12px;
    color: #666;
}
code {
    background-color: #f5f5f5;
    padding: 2px 4px;
    border-radius: 4px;
    font-family: monospace;
}
</style>
{% endblock %}

{% block content %}
<div class="main-content">
    <h1>P_Convert_2025_Special (PDF:Word-Image-Equation)</h1>
    <p>C√¥ng c·ª• chuy·ªÉn ƒë·ªïi PDF th√†nh vƒÉn b·∫£n, h√¨nh ·∫£nh v√† c√¥ng th·ª©c to√°n h·ªçc</p>
    
    <!-- API Keys Card -->
    <div class="card">
        <h2 class="card-title">API Keys</h2>
        <div class="form-group">
            <label for="mineru-token">Mineru Token</label>
            <input type="password" id="mineru-token" placeholder="Nh·∫≠p Mineru Token...">
            <button class="btn-toggle-password" data-target="mineru-token">üëÅ</button>
        </div>
        <div class="form-group">
            <label for="gemini-key">Gemini API Key</label>
            <input type="password" id="gemini-key" placeholder="Nh·∫≠p Gemini API Key...">
            <button class="btn-toggle-password" data-target="gemini-key">üëÅ</button>
        </div>
    </div>
    
    <!-- File Upload Card -->
    <div class="card">
        <h2 class="card-title">Upload PDF</h2>
        <div class="file-drop-area" id="file-drop-area">
            <p>K√©o th·∫£ file PDF v√†o ƒë√¢y ho·∫∑c <strong>Click ƒë·ªÉ ch·ªçn file</strong></p>
            <input type="file" id="file-input" class="file-input" accept=".pdf">
        </div>
        
        <div id="file-info-container" class="hidden">
            <div class="file-info">
                <div class="file-name" id="file-name"></div>
                <div class="file-size" id="file-size"></div>
                <button class="btn-error" id="btn-remove-file">X√≥a</button>
            </div>
        </div>
    </div>
    
    <!-- Tabs Card -->
    <div class="card" id="processing-options" style="display: none;">
        <div class="tabs">
            <div class="tab active" data-tab="full-pdf">X·ª≠ l√Ω to√†n b·ªô PDF</div>
            <div class="tab" data-tab="split-pdf">T√°ch v√† x·ª≠ l√Ω t·ª´ng ph·∫ßn</div>
        </div>
        
        <!-- Tab Content -->
        <div class="tab-content active" id="full-pdf-tab">
            <p>X·ª≠ l√Ω to√†n b·ªô file PDF v√† tr√≠ch xu·∫•t th√†nh vƒÉn b·∫£n</p>
            <button class="btn" id="btn-process-all">Upload & Parse (To√†n b·ªô PDF)</button>
            <div class="progress-container" id="progress-container-full" style="display: none;">
                <div class="progress-bar" id="progress-bar-full"></div>
            </div>
            <div id="status-text-full" class="status-text"></div>
        </div>
        
        <div class="tab-content" id="split-pdf-tab">
            <p>T√°ch PDF th√†nh nhi·ªÅu ph·∫ßn ƒë·ªÉ x·ª≠ l√Ω t·ª´ng ph·∫ßn</p>
            <button class="btn" id="btn-split-pdf">T√°ch PDF</button>
            <div id="parts-container" style="display: none;">
                <h3>C√°c ph·∫ßn ƒë√£ t√°ch</h3>
                <ul class="parts-list" id="parts-list"></ul>
                <div class="action-buttons">
                    <button class="btn" id="btn-process-selected-part">X·ª≠ l√Ω ph·∫ßn ƒë√£ ch·ªçn</button>
                    <button class="btn" id="btn-process-all-parts">X·ª≠ l√Ω t·∫•t c·∫£ c√°c ph·∫ßn</button>
                </div>
                <div class="progress-container" id="progress-container-part" style="display: none;">
                    <div class="progress-bar" id="progress-bar-part"></div>
                </div>
                <div id="status-text-part" class="status-text"></div>
            </div>
        </div>
    </div>
    
    <!-- Results Card -->
    <div class="card" id="results-card" style="display: none;">
        <h2 class="card-title">K·∫øt qu·∫£</h2>
        <div class="tabs">
            <div class="tab active" data-tab="preview">Xem k·∫øt qu·∫£</div>
            <div class="tab" data-tab="download">T·∫£i xu·ªëng</div>
        </div>
        
        <div class="tab-content active" id="preview-tab">
            <div class="markdown-preview" id="markdown-preview"></div>
        </div>
        
        <div class="tab-content" id="download-tab">
            <p>T·∫£i xu·ªëng k·∫øt qu·∫£</p>
            <div class="action-buttons">
                <a class="btn" id="btn-download-md">T·∫£i xu·ªëng d∆∞·ªõi d·∫°ng Markdown</a>
                <a class="btn" id="btn-download-txt">T·∫£i xu·ªëng d∆∞·ªõi d·∫°ng Text</a>
                <button class="btn btn-success" id="btn-to-word">Chuy·ªÉn sang Word (API)</button>
            </div>
            
            <!-- Loading spinner v√† status message cho Word conversion -->
            <div class="loading-spinner" id="outputLoading">
                <div class="spinner"></div>
                <span>ƒêang x·ª≠ l√Ω...</span>
            </div>
            <div class="status-message" id="status-message"></div>
            <div class="progress-text" id="progress-text"></div>
            
            <div class="alert alert-info">
                Ch·ª©c nƒÉng chuy·ªÉn ƒë·ªïi sang Word h·ªó tr·ª£ c·∫£ h√¨nh ·∫£nh t·ª´ server v√† blob URLs. N·∫øu g·∫∑p v·∫•n ƒë·ªÅ v·ªõi n·ªôi dung l·ªõn, b·∫°n c√≥ th·ªÉ t·∫£i xu·ªëng Markdown v√† s·ª≠ d·ª•ng Pandoc c·ª•c b·ªô.
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Variables
    let fileId = null;
    let fileName = null;
    let fileData = null;
    let activeTaskId = null;
    let selectedPartId = null;
    let parts = [];
    let resultText = '';
    let currentMarkdownContent = ''; // Bi·∫øn l∆∞u n·ªôi dung markdown hi·ªán t·∫°i
    
    // Elements
    const fileDropArea = document.getElementById('file-drop-area');
    const fileInput = document.getElementById('file-input');
    const fileInfoContainer = document.getElementById('file-info-container');
    const fileNameEl = document.getElementById('file-name');
    const fileSizeEl = document.getElementById('file-size');
    const btnRemoveFile = document.getElementById('btn-remove-file');
    const processingOptions = document.getElementById('processing-options');
    const btnProcessAll = document.getElementById('btn-process-all');
    const btnSplitPdf = document.getElementById('btn-split-pdf');
    const progressContainerFull = document.getElementById('progress-container-full');
    const progressBarFull = document.getElementById('progress-bar-full');
    const statusTextFull = document.getElementById('status-text-full');
    const partsContainer = document.getElementById('parts-container');
    const partsList = document.getElementById('parts-list');
    const btnProcessSelectedPart = document.getElementById('btn-process-selected-part');
    const btnProcessAllParts = document.getElementById('btn-process-all-parts');
    const progressContainerPart = document.getElementById('progress-container-part');
    const progressBarPart = document.getElementById('progress-bar-part');
    const statusTextPart = document.getElementById('status-text-part');
    const resultsCard = document.getElementById('results-card');
    const markdownPreview = document.getElementById('markdown-preview');
    const btnDownloadMd = document.getElementById('btn-download-md');
    const btnDownloadTxt = document.getElementById('btn-download-txt');
    const btnToWord = document.getElementById('btn-to-word');
    const outputLoading = document.getElementById('outputLoading');
    const statusMessage = document.getElementById('status-message');
    const progressText = document.getElementById('progress-text');
    
    // Password Toggle
    document.querySelectorAll('.btn-toggle-password').forEach(function(button) {
        button.addEventListener('click', function() {
            const targetId = this.getAttribute('data-target');
            const input = document.getElementById(targetId);
            if (input.type === 'password') {
                input.type = 'text';
            } else {
                input.type = 'password';
            }
        });
    });
    
    // Tab Switching
    document.querySelectorAll('.tab').forEach(function(tab) {
        tab.addEventListener('click', function() {
            const tabId = this.getAttribute('data-tab');
            
            // Update active tab
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            this.classList.add('active');
            
            // Update active tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabId + '-tab').classList.add('active');
        });
    });
    
    // File Upload Handling
    fileDropArea.addEventListener('click', function() {
        fileInput.click();
    });
    
    fileDropArea.addEventListener('dragover', function(e) {
        e.preventDefault();
        fileDropArea.classList.add('dragover');
    });
    
    fileDropArea.addEventListener('dragleave', function() {
        fileDropArea.classList.remove('dragover');
    });
    
    fileDropArea.addEventListener('drop', function(e) {
        e.preventDefault();
        fileDropArea.classList.remove('dragover');
        
        if (e.dataTransfer.files.length) {
            handleFileUpload(e.dataTransfer.files[0]);
        }
    });
    
    fileInput.addEventListener('change', function() {
        if (fileInput.files.length) {
            handleFileUpload(fileInput.files[0]);
        }
    });
    
    btnRemoveFile.addEventListener('click', function() {
        resetFileUpload();
    });
    
    function handleFileUpload(file) {
        if (!file.type || file.type !== 'application/pdf') {
            alert('Ch·ªâ ch·∫•p nh·∫≠n file PDF!');
            return;
        }
        
        // Display file info
        fileName = file.name;
        fileNameEl.textContent = fileName;
        fileSizeEl.textContent = formatFileSize(file.size);
        fileInfoContainer.style.display = 'block';
        processingOptions.style.display = 'block';
        
        // Upload file to server
        const formData = new FormData();
        formData.append('pdf_file', file);
        
        fetch('/upload', {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                fileId = data.file_id;
                // Show success message
                console.log('File uploaded successfully', data);
            } else {
                alert(data.error || 'Upload failed');
                resetFileUpload();
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error uploading file');
            resetFileUpload();
        });
    }
    
    function resetFileUpload() {
        fileInput.value = '';
        fileInfoContainer.style.display = 'none';
        processingOptions.style.display = 'none';
        partsContainer.style.display = 'none';
        resultsCard.style.display = 'none';
        fileId = null;
        fileName = null;
        parts = [];
        currentMarkdownContent = '';
    }
    
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    // Process Full PDF
    btnProcessAll.addEventListener('click', function() {
        if (!fileId) {
            alert('Vui l√≤ng ch·ªçn file PDF tr∆∞·ªõc');
            return;
        }
        
        const mineruToken = document.getElementById('mineru-token').value;
        const geminiKey = document.getElementById('gemini-key').value;
        
        if (!mineruToken) {
            alert('Vui l√≤ng nh·∫≠p Mineru Token');
            return;
        }
        
        // Show progress bar
        progressContainerFull.style.display = 'block';
        progressBarFull.style.width = '0%';
        statusTextFull.textContent = 'ƒêang b·∫Øt ƒë·∫ßu x·ª≠ l√Ω...';
        btnProcessAll.disabled = true;
        
        fetch('/process', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                file_id: fileId,
                filename: fileName,
                mineru_token: mineruToken,
                gemini_key: geminiKey
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                activeTaskId = data.task_id;
                // Poll for task status
                pollTaskStatus(activeTaskId, updateFullPdfProgress);
            } else {
                alert(data.error || 'Processing failed');
                progressContainerFull.style.display = 'none';
                btnProcessAll.disabled = false;
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error processing file');
            progressContainerFull.style.display = 'none';
            btnProcessAll.disabled = false;
        });
    });
    
    function updateFullPdfProgress(taskInfo) {
        progressBarFull.style.width = taskInfo.progress + '%';
        
        switch (taskInfo.status) {
            case 'initialized':
                statusTextFull.textContent = 'Kh·ªüi t·∫°o...';
                break;
            case 'uploading':
                statusTextFull.textContent = 'ƒêang upload PDF...';
                break;
            case 'processing':
                statusTextFull.textContent = 'ƒêang x·ª≠ l√Ω PDF...';
                break;
            case 'downloading':
                statusTextFull.textContent = 'ƒêang t·∫£i k·∫øt qu·∫£...';
                break;
            case 'correcting':
                statusTextFull.textContent = 'ƒêang hi·ªáu ƒë√≠nh n·ªôi dung v·ªõi Gemini...';
                break;
            case 'completed':
                statusTextFull.textContent = 'ƒê√£ ho√†n th√†nh!';
                getTaskResult(activeTaskId);
                btnProcessAll.disabled = false;
                break;
            case 'error':
                statusTextFull.textContent = 'L·ªói: ' + taskInfo.error;
                btnProcessAll.disabled = false;
                break;
            case 'cancelled':
                statusTextFull.textContent = 'ƒê√£ h·ªßy x·ª≠ l√Ω';
                btnProcessAll.disabled = false;
                break;
            default:
                statusTextFull.textContent = 'ƒêang x·ª≠ l√Ω...';
        }
    }
    
    // Split PDF
    btnSplitPdf.addEventListener('click', function() {
        if (!fileId) {
            alert('Vui l√≤ng ch·ªçn file PDF tr∆∞·ªõc');
            return;
        }
        
        btnSplitPdf.disabled = true;
        statusTextPart.textContent = 'ƒêang t√°ch PDF...';
        
        fetch('/split-pdf', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                file_id: fileId,
                filename: fileName
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                parts = data.parts;
                
                // Display parts list
                partsList.innerHTML = '';
                parts.forEach(part => {
                    const li = document.createElement('li');
                    li.className = 'part-item';
                    li.dataset.partId = part.id;
                    li.textContent = part.name;
                    li.addEventListener('click', function() {
                        // Select part
                        document.querySelectorAll('.part-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        this.classList.add('selected');
                        selectedPartId = part.id;
                    });
                    partsList.appendChild(li);
                });
                
                partsContainer.style.display = 'block';
                statusTextPart.textContent = 'PDF ƒë√£ ƒë∆∞·ª£c t√°ch th√†nh ' + parts.length + ' ph·∫ßn';
            } else {
                alert(data.error || 'Split failed');
            }
            btnSplitPdf.disabled = false;
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error splitting file');
            btnSplitPdf.disabled = false;
        });
    });
    
    // Process Selected Part
    btnProcessSelectedPart.addEventListener('click', function() {
        if (!selectedPartId) {
            alert('Vui l√≤ng ch·ªçn m·ªôt ph·∫ßn ƒë·ªÉ x·ª≠ l√Ω');
            return;
        }
        
        processSelectedPart(selectedPartId);
    });
    
    function processSelectedPart(partId) {
        const mineruToken = document.getElementById('mineru-token').value;
        const geminiKey = document.getElementById('gemini-key').value;
        
        if (!mineruToken) {
            alert('Vui l√≤ng nh·∫≠p Mineru Token');
            return;
        }
        
        // Show progress
        progressContainerPart.style.display = 'block';
        progressBarPart.style.width = '0%';
        statusTextPart.textContent = 'ƒêang b·∫Øt ƒë·∫ßu x·ª≠ l√Ω ph·∫ßn ' + partId + '...';
        btnProcessSelectedPart.disabled = true;
        btnProcessAllParts.disabled = true;
        
        fetch('/process-part', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                file_id: fileId,
                part_id: partId,
                mineru_token: mineruToken,
                gemini_key: geminiKey
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                activeTaskId = data.task_id;
                // Poll for task status
                pollTaskStatus(activeTaskId, updatePartProgress);
            } else {
                alert(data.error || 'Processing failed');
                progressContainerPart.style.display = 'none';
                btnProcessSelectedPart.disabled = false;
                btnProcessAllParts.disabled = false;
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error processing part');
            progressContainerPart.style.display = 'none';
            btnProcessSelectedPart.disabled = false;
            btnProcessAllParts.disabled = false;
        });
    }
    
    // Process All Parts
    btnProcessAllParts.addEventListener('click', function() {
        if (parts.length === 0) {
            alert('Kh√¥ng c√≥ ph·∫ßn n√†o ƒë·ªÉ x·ª≠ l√Ω');
            return;
        }
        
        // Reset result text before processing all parts
        resultText = '';
        
        // Process first part
        processAllPartsSequentially(0);
    });
    
    function processAllPartsSequentially(index) {
        if (index >= parts.length) {
            // All parts are processed
            btnProcessSelectedPart.disabled = false;
            btnProcessAllParts.disabled = false;
            return;
        }
        
        const partId = parts[index].id;
        const mineruToken = document.getElementById('mineru-token').value;
        const geminiKey = document.getElementById('gemini-key').value;
        
        if (!mineruToken) {
            alert('Vui l√≤ng nh·∫≠p Mineru Token');
            return;
        }
        
        // Show progress
        progressContainerPart.style.display = 'block';
        progressBarPart.style.width = '0%';
        statusTextPart.textContent = `ƒêang x·ª≠ l√Ω ph·∫ßn ${index+1}/${parts.length}...`;
        btnProcessSelectedPart.disabled = true;
        btnProcessAllParts.disabled = true;
        
        fetch('/process-part', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                file_id: fileId,
                part_id: partId,
                mineru_token: mineruToken,
                gemini_key: geminiKey
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                activeTaskId = data.task_id;
                
                // Set up callback for when this part is done
                const originalPollCallback = pollTaskStatus(activeTaskId, updatePartProgress, () => {
                    // After this part is done, process the next part
                    setTimeout(() => {
                        processAllPartsSequentially(index + 1);
                    }, 1000);
                });
            } else {
                alert(data.error || 'Processing failed');
                progressContainerPart.style.display = 'none';
                btnProcessSelectedPart.disabled = false;
                btnProcessAllParts.disabled = false;
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error processing parts');
            progressContainerPart.style.display = 'none';
            btnProcessSelectedPart.disabled = false;
            btnProcessAllParts.disabled = false;
        });
    }
    
    function updatePartProgress(taskInfo) {
        progressBarPart.style.width = taskInfo.progress + '%';
        
        switch (taskInfo.status) {
            case 'initialized':
                statusTextPart.textContent = 'Kh·ªüi t·∫°o...';
                break;
            case 'uploading':
                statusTextPart.textContent = 'ƒêang upload PDF...';
                break;
            case 'processing':
                statusTextPart.textContent = 'ƒêang x·ª≠ l√Ω PDF...';
                break;
            case 'downloading':
                statusTextPart.textContent = 'ƒêang t·∫£i k·∫øt qu·∫£...';
                break;
            case 'correcting':
                statusTextPart.textContent = 'ƒêang hi·ªáu ƒë√≠nh n·ªôi dung v·ªõi Gemini...';
                break;
            case 'completed':
                statusTextPart.textContent = 'ƒê√£ ho√†n th√†nh!';
                getTaskResult(activeTaskId, true);
                btnProcessSelectedPart.disabled = false;
                btnProcessAllParts.disabled = false;
                break;
            case 'error':
                statusTextPart.textContent = 'L·ªói: ' + taskInfo.error;
                btnProcessSelectedPart.disabled = false;
                btnProcessAllParts.disabled = false;
                break;
            case 'cancelled':
                statusTextPart.textContent = 'ƒê√£ h·ªßy x·ª≠ l√Ω';
                btnProcessSelectedPart.disabled = false;
                btnProcessAllParts.disabled = false;
                break;
            default:
                statusTextPart.textContent = 'ƒêang x·ª≠ l√Ω...';
        }
    }
    
    // Task Status Polling
    function pollTaskStatus(taskId, updateCallback, completionCallback = null) {
        const poll = () => {
            fetch(`/task-status/${taskId}`)
                .then(response => response.json())
                .then(taskInfo => {
                    updateCallback(taskInfo);
                    
                    if (['completed', 'error', 'cancelled'].includes(taskInfo.status)) {
                        if (completionCallback) {
                            completionCallback();
                        }
                        return;
                    }
                    
                    // Continue polling
                    setTimeout(poll, 1000);
                })
                .catch(error => {
                    console.error('Error polling task status:', error);
                    // Retry after a delay
                    setTimeout(poll, 2000);
                });
        };
        
        // Start polling
        poll();
    }
    
    // Get Task Result
    function getTaskResult(taskId, append = false) {
        fetch(`/task-result/${taskId}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    if (append) {
                        // Append result to existing text
                        if (resultText) {
                            resultText += '\n\n';
                        }
                        
                        if (data.part_name) {
                            resultText += `--- K·∫øt qu·∫£ t·ª´ ${data.part_name} ---\n`;
                        }
                        
                        resultText += data.result;
                    } else {
                        // Replace existing result
                        resultText = data.result;
                    }
                    
                    // Update current markdown content for Word conversion
                    currentMarkdownContent = resultText;
                    
                    // Update preview
                    markdownPreview.innerHTML = marked.parse(resultText);
                    
                    // Update download links
                    btnDownloadMd.href = `/download/${taskId}/markdown`;
                    btnDownloadTxt.href = `/download/${taskId}/text`;
                    
                    // Show results card
                    resultsCard.style.display = 'block';
                }
            })
            .catch(error => {
                console.error('Error getting result:', error);
            });
    }
    
    // Hi·ªÉn th·ªã th√¥ng b√°o tr·∫°ng th√°i
    function showStatus(message, type) {
        statusMessage.innerHTML = message;
        statusMessage.className = 'status-message ' + type;
        statusMessage.style.display = 'block';
        
        // T·ª± ƒë·ªông ·∫©n th√¥ng b√°o th√†nh c√¥ng sau 5 gi√¢y
        if (type === 'success') {
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        }
    }
    
    // Hi·ªÉn th·ªã th√¥ng tin ti·∫øn tr√¨nh
    function showProgressInfo(message) {
        progressText.textContent = message;
        progressText.style.display = 'block';
    }
    
    // H√†m chuy·ªÉn ƒë·ªïi h√¨nh ·∫£nh sang base64
    async function convertImageToBase64(blobUrl, maxWidth = 800, quality = 0.7) {
      try {
        // T·∫£i h√¨nh ·∫£nh t·ª´ blob URL
        const response = await fetch(blobUrl);
        const imageBlob = await response.blob();
        
        return new Promise((resolve, reject) => {
          // T·∫°o m·ªôt ƒë·ªëi t∆∞·ª£ng Image
          const img = new Image();
          img.onload = () => {
            // T·∫°o canvas ƒë·ªÉ resize h√¨nh ·∫£nh
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;
            
            // Gi·∫£m k√≠ch th∆∞·ªõc n·∫øu c·∫ßn
            if (width > maxWidth) {
              height = Math.floor(height * (maxWidth / width));
              width = maxWidth;
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // V·∫Ω h√¨nh ·∫£nh ƒë√£ resize v√†o canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            // Chuy·ªÉn ƒë·ªïi canvas th√†nh base64 v·ªõi ch·∫•t l∆∞·ª£ng t√πy ch·ªânh
            const base64 = canvas.toDataURL('image/jpeg', quality);
            resolve(base64);
          };
          
          img.onerror = () => {
            // N·∫øu kh√¥ng th·ªÉ optimize, tr·∫£ v·ªÅ d·ªØ li·ªáu g·ªëc d∆∞·ªõi d·∫°ng base64
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(imageBlob);
          };
          
          // Thi·∫øt l·∫≠p src cho h√¨nh ·∫£nh
          img.src = URL.createObjectURL(imageBlob);
        });
      } catch (error) {
        console.error('L·ªói khi chuy·ªÉn ƒë·ªïi h√¨nh ·∫£nh sang base64:', error);
        return null;
      }
    }
    
    // H√†m t·∫£i v√† chuy·ªÉn ƒë·ªïi h√¨nh ·∫£nh t·ª´ m√°y ch·ªß sang base64
    async function fetchAndConvertToBase64(imgPath, maxWidth = 800, quality = 0.7) {
      try {
        // T·∫°o URL tuy·ªát ƒë·ªëi t·ª´ ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi
        const absoluteUrl = new URL(imgPath, window.location.origin).href;
        
        // T·∫£i h√¨nh ·∫£nh t·ª´ m√°y ch·ªß
        const response = await fetch(absoluteUrl);
        if (!response.ok) {
          throw new Error(`Kh√¥ng th·ªÉ t·∫£i h√¨nh ·∫£nh: ${response.status} ${response.statusText}`);
        }
        
        // Chuy·ªÉn ƒë·ªïi th√†nh blob
        const blob = await response.blob();
        
        // T·∫°o ƒë·ªëi t∆∞·ª£ng Image ƒë·ªÉ resize
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            // T·∫°o canvas ƒë·ªÉ resize h√¨nh ·∫£nh
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;
            
            // Gi·∫£m k√≠ch th∆∞·ªõc n·∫øu c·∫ßn
            if (width > maxWidth) {
              height = Math.floor(height * (maxWidth / width));
              width = maxWidth;
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // V·∫Ω h√¨nh ·∫£nh ƒë√£ resize v√†o canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            
            // Chuy·ªÉn ƒë·ªïi canvas th√†nh base64 v·ªõi ch·∫•t l∆∞·ª£ng t√πy ch·ªânh
            const base64 = canvas.toDataURL('image/jpeg', quality);
            resolve(base64);
          };
          
          img.onerror = () => {
            // N·∫øu kh√¥ng th·ªÉ t·∫£i ho·∫∑c optimize, chuy·ªÉn ƒë·ªïi blob tr·ª±c ti·∫øp
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          };
          
          // Thi·∫øt l·∫≠p src cho h√¨nh ·∫£nh
          img.src = URL.createObjectURL(blob);
        });
      } catch (error) {
        console.error('L·ªói khi t·∫£i v√† chuy·ªÉn ƒë·ªïi h√¨nh ·∫£nh t·ª´ m√°y ch·ªß:', error);
        return null;
      }
    }
    
    // H√†m chu·∫©n b·ªã markdown v·ªõi h·ªó tr·ª£ c·∫£ ƒë∆∞·ªùng d·∫´n m√°y ch·ªß v√† blob URL
    async function prepareMarkdownForPandoc(markdownContent) {
      // T·∫°o ƒë·ªëi t∆∞·ª£ng ƒë·ªÉ theo d√µi qu√° tr√¨nh
      showStatus('ƒêang b·∫Øt ƒë·∫ßu x·ª≠ l√Ω h√¨nh ·∫£nh...', 'info');
      
      // Regex ƒë·ªÉ t√¨m t·∫•t c·∫£ h√¨nh ·∫£nh trong markdown (bao g·ªìm c·∫£ ƒë∆∞·ªùng d·∫´n tƒ©nh v√† blob)
      const imgRegex = /!\[(.*?)\]\((\/images\/.*?|blob:.*?|data:image\/.*?)\)/g;
      let result = markdownContent;
      let matches = [];
      let match;
      
      // T√¨m t·∫•t c·∫£ c√°c tham chi·∫øu h√¨nh ·∫£nh c·∫ßn x·ª≠ l√Ω
      while ((match = imgRegex.exec(markdownContent)) !== null) {
        matches.push({
          fullMatch: match[0],
          altText: match[1],
          imgPath: match[2]
        });
      }
      
      console.log(`ƒêang x·ª≠ l√Ω ${matches.length} h√¨nh ·∫£nh...`);
      showStatus(`ƒêang x·ª≠ l√Ω ${matches.length} h√¨nh ·∫£nh...`, 'info');
      
      // X·ª≠ l√Ω t·ª´ng h√¨nh ·∫£nh m·ªôt - c√°ch ti·∫øp c·∫≠n tu·∫ßn t·ª±
      for (let i = 0; i < matches.length; i++) {
        const item = matches[i];
        try {
          let base64Data;
          
          // C·∫≠p nh·∫≠t tr·∫°ng th√°i
          showProgressInfo(`ƒêang x·ª≠ l√Ω h√¨nh ·∫£nh ${i+1}/${matches.length}...`);
          
          if (item.imgPath.startsWith('/images/')) {
            // ƒê∆∞·ªùng d·∫´n tƒ©nh t·ª´ m√°y ch·ªß - s·ª≠ d·ª•ng fetch API
            base64Data = await fetchAndConvertToBase64(item.imgPath, 600, 0.6);
          } else if (item.imgPath.startsWith('blob:') || item.imgPath.startsWith('data:image/')) {
            // Blob URL ho·∫∑c data URL - s·ª≠ d·ª•ng ph∆∞∆°ng ph√°p chuy·ªÉn ƒë·ªïi kh√°c
            base64Data = await convertImageToBase64(item.imgPath, 600, 0.6);
          }
          
          if (base64Data) {
            // Thay th·∫ø trong n·ªôi dung markdown
            result = result.replace(item.fullMatch, `![${item.altText}](${base64Data})`);
          }
        } catch (err) {
          console.error(`Kh√¥ng th·ªÉ x·ª≠ l√Ω h√¨nh ·∫£nh: ${item.imgPath.substring(0, 50)}...`, err);
        }
      }
      
      return result;
    }
    
    // H√†m chia n·ªôi dung th√†nh c√°c ph·∫ßn nh·ªè h∆°n
    function splitIntoChunks(markdownContent, maxChunkSize = 500000) {
      const chunks = [];
      let currentChunk = "";
      
      // T√°ch markdown th√†nh c√°c d√≤ng
      const lines = markdownContent.split('\n');
      
      for (const line of lines) {
        // N·∫øu th√™m d√≤ng hi·ªán t·∫°i v√†o chunk hi·ªán t·∫°i kh√¥ng v∆∞·ª£t qu√° k√≠ch th∆∞·ªõc t·ªëi ƒëa
        if ((currentChunk.length + line.length + 1) <= maxChunkSize) {
          currentChunk += line + '\n';
        } else {
          // N·∫øu v∆∞·ª£t qu√°, l∆∞u chunk hi·ªán t·∫°i v√† b·∫Øt ƒë·∫ßu chunk m·ªõi
          chunks.push(currentChunk);
          currentChunk = line + '\n';
        }
      }
      
      // Th√™m chunk cu·ªëi c√πng
      if (currentChunk.length > 0) {
        chunks.push(currentChunk);
      }
      
      return chunks;
    }
    
    // H√†m chuy·ªÉn ƒë·ªïi sang word v·ªõi h·ªó tr·ª£ h√¨nh ·∫£nh m√°y ch·ªß
    async function convertOutputToWord() {
      if (!currentMarkdownContent || !currentMarkdownContent.trim()) {
        alert("Kh√¥ng c√≥ k·∫øt qu·∫£ ƒë·ªÉ chuy·ªÉn sang Word!");
        return;
      }
      
      outputLoading.style.display = 'block';
      
      try {
        // X·ª≠ l√Ω h√¨nh ·∫£nh tr∆∞·ªõc khi g·ª≠i ƒë·∫øn Pandoc
        const processedMarkdown = await prepareMarkdownForPandoc(currentMarkdownContent);
        
        // Log k√≠ch th∆∞·ªõc c·ªßa d·ªØ li·ªáu ƒë√£ x·ª≠ l√Ω
        const contentSizeKB = Math.round(processedMarkdown.length / 1024);
        console.log(`K√≠ch th∆∞·ªõc Markdown sau khi x·ª≠ l√Ω: ${contentSizeKB} KB`);
        showProgressInfo(`K√≠ch th∆∞·ªõc d·ªØ li·ªáu: ${contentSizeKB} KB`);
        
        // Ki·ªÉm tra k√≠ch th∆∞·ªõc - n·∫øu qu√° l·ªõn th√¨ c·∫ßn ph∆∞∆°ng ph√°p kh√°c
        if (contentSizeKB > 1000) {
          showStatus('N·ªôi dung qu√° l·ªõn cho API. ƒêang chuy·ªÉn sang ph∆∞∆°ng ph√°p t·∫£i xu·ªëng tr·ª±c ti·∫øp...', 'warning');
          
          // T·∫°o t√™n file c√≥ timestamp
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const fileName = `document_${timestamp}.md`;
          
          // T·∫°o link t·∫£i tr·ª±c ti·∫øp cho Markdown
          const blob = new Blob([processedMarkdown], { type: 'text/markdown' });
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fileName;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
          
          showStatus('File Markdown ƒë√£ ƒë∆∞·ª£c t·∫£i xu·ªëng. S·ª≠ d·ª•ng Pandoc c·ª•c b·ªô v·ªõi l·ªánh: <br><code>pandoc ' + fileName + ' -o output.docx</code>', 'info');
          return;
        }
        
        // N·∫øu k√≠ch th∆∞·ªõc cho ph√©p, ti·∫øp t·ª•c v·ªõi API
        showStatus('ƒêang chuy·ªÉn ƒë·ªïi sang Word...', 'info');
        
        const response = await fetch('https://pandoc-api.onrender.com/convert', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/octet-stream'
          },
          body: JSON.stringify({ markdown: processedMarkdown })
        });
        
        if (!response.ok) {
          const errorText = await response.text().catch(() => '');
          throw new Error(`HTTP error! status: ${response.status}${errorText ? ': ' + errorText : ''}`);
        }
        
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        
        // T·∫°o t√™n file c√≥ timestamp
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        a.download = `document_${timestamp}.docx`;
        
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        
        // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
        showStatus('Xu·∫•t file Word th√†nh c√¥ng!', 'success');
      } catch (error) {
        console.error('Error:', error);
        if (error.message.includes('CORS')) {
          showStatus('L·ªói CORS: Website hi·ªán t·∫°i kh√¥ng ƒë∆∞·ª£c ph√©p g·ªçi API Pandoc.', 'danger');
        } else if (error.message.includes('413') || error.message.includes('payload too large')) {
          showStatus('L·ªói: N·ªôi dung qu√° l·ªõn ƒë·ªÉ x·ª≠ l√Ω qua API. Vui l√≤ng s·ª≠ d·ª•ng Pandoc c·ª•c b·ªô.', 'danger');
        } else if (error.message.includes('500')) {
          showStatus('L·ªói m√°y ch·ªß: API Pandoc kh√¥ng th·ªÉ x·ª≠ l√Ω y√™u c·∫ßu.', 'danger');
        } else {
          showStatus('C√≥ l·ªói x·∫£y ra khi chuy·ªÉn ƒë·ªïi: ' + error.message, 'danger');
        }
      } finally {
        outputLoading.style.display = 'none';
      }
    }
    
    // Th√™m event listener cho n√∫t chuy·ªÉn sang Word
    btnToWord.addEventListener('click', convertOutputToWord);
});
</script>
{% endblock %}
